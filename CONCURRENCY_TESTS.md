# 동시성 통합 테스트

이 문서는 이커머스 프로젝트의 동시성 시나리오를 검증하기 위한 통합 테스트 계획을 설명합니다.

## 테스트 개요

동시성 이슈가 발생할 수 있는 주요 비즈니스 로직에 대해 통합 테스트를 작성하여 비관적 락(Pessimistic Lock)이 올바르게 동작하는지 검증합니다.

## 테스트 파일 위치

```
src/test/java/io/hhplus/ECommerce/ECommerce_project/integration/concurrency/
├── StockConcurrencyTest.java      # 재고 동시성 테스트
├── PaymentConcurrencyTest.java    # 결제 동시성 테스트
└── CouponConcurrencyTest.java     # 쿠폰 동시성 테스트
```

## 1. 재고 동시성 테스트 (StockConcurrencyTest)

### 목적
여러 사용자가 동시에 같은 상품을 주문할 때 재고가 정확하게 차감되는지 검증

### 테스트 시나리오

#### 1.1 기본 동시성 테스트
- **Given**: 재고 10개인 상품
- **When**: 20명의 사용자가 동시에 1개씩 주문
- **Then**:
  - 10개 주문만 성공
  - 10개 주문은 실패 (재고 부족)
  - 최종 재고는 0
  - 판매량은 10

#### 1.2 동일 사용자 동시 주문
- **Given**: 재고 10개인 상품
- **When**: 1명의 사용자가 동시에 2개씩 5번 주문
- **Then**:
  - 5번 주문 모두 성공
  - 최종 재고는 0
  - 판매량은 10

#### 1.3 재고 부족 상황
- **Given**: 재고 3개인 상품
- **When**: 10명의 사용자가 동시에 1개씩 주문
- **Then**:
  - 3개 주문만 성공
  - 7개 주문은 실패
  - 최종 재고는 0

### 핵심 검증 포인트
- `ProductRepository.findByIdWithLock()` 비관적 락이 동작하는지
- 재고 차감이 원자적(atomic)으로 처리되는지
- 동시 요청 시 데이터 정합성이 유지되는지

---

## 2. 결제 동시성 테스트 (PaymentConcurrencyTest)

### 목적
주문과 결제가 분리된 상황에서 동시 결제 요청 시 상태가 올바르게 관리되는지 검증

### 테스트 시나리오

#### 2.1 동일 주문 중복 결제 방지
- **Given**: 주문 1개 (COMPLETED 상태)
- **When**: 동시에 5번 결제 시도
- **Then**:
  - 1번만 결제 성공
  - 4번은 실패 (이미 결제된 주문)
  - 주문 상태는 PAID

#### 2.2 서로 다른 주문 동시 결제
- **Given**: 주문 10개 (모두 COMPLETED 상태)
- **When**: 10개 주문에 대해 동시 결제
- **Then**:
  - 모든 결제 성공
  - 모든 주문 상태가 PAID

#### 2.3 주문과 결제 동시 처리
- **Given**: 없음
- **When**: 10개 주문 생성과 각각의 결제가 동시에 발생
- **Then**:
  - 모든 주문 생성 성공
  - 모든 결제 성공
  - 주문 상태가 순차적으로 COMPLETED → PAID로 변경

### 핵심 검증 포인트
- 주문 상태 변경이 안전하게 처리되는지
- 동일 주문에 대한 중복 결제가 방지되는지
- 트랜잭션 격리 수준이 올바르게 설정되었는지

---

## 3. 쿠폰 동시성 테스트 (CouponConcurrencyTest)

### 목적
제한된 쿠폰을 여러 사용자가 동시에 사용할 때 사용 횟수 제한이 올바르게 적용되는지 검증

### 테스트 시나리오

#### 3.1 총 사용 횟수 제한
- **Given**: 총 10번 사용 가능한 쿠폰
- **When**: 20명의 사용자가 동시에 쿠폰 사용
- **Then**:
  - 10개 주문만 성공 (쿠폰 적용됨)
  - 10개 주문은 실패 (쿠폰 사용 횟수 초과)
  - 쿠폰 사용 횟수는 10

#### 3.2 사용자별 사용 횟수 제한
- **Given**: 사용자당 1번만 사용 가능한 쿠폰
- **When**: 1명의 사용자가 동시에 5번 주문 시도
- **Then**:
  - 1개 주문만 성공
  - 4개 주문은 실패
  - UserCoupon 사용 횟수는 1

#### 3.3 충분한 쿠폰 동시 사용
- **Given**: 100번 사용 가능한 쿠폰
- **When**: 20명의 사용자가 동시에 쿠폰 사용
- **Then**:
  - 모든 주문 성공
  - 쿠폰 사용 횟수는 20

### 핵심 검증 포인트
- `Coupon.increaseUsageCount()` 동시 호출 시 정확성
- `UserCoupon.use()` 동시 호출 시 정확성
- 쿠폰 사용 횟수 카운팅이 정확한지

---

## 테스트 기술 스택

- **프레임워크**: JUnit 5
- **Assertion**: AssertJ
- **동시성 제어**:
  - `ExecutorService` (스레드 풀)
  - `CountDownLatch` (동기화)
  - `AtomicInteger` (카운터)

## 테스트 실행 방법

```bash
# 전체 동시성 테스트 실행
./gradlew test --tests "*.concurrency.*"

# 개별 테스트 클래스 실행
./gradlew test --tests "StockConcurrencyTest"
./gradlew test --tests "PaymentConcurrencyTest"
./gradlew test --tests "CouponConcurrencyTest"
```

## 주의사항

1. **엔티티 메서드 시그니처 확인 필요**
   - 현재 테스트 코드는 엔티티의 정적 팩토리 메서드 시그니처와 맞지 않을 수 있습니다
   - 실제 구현 시 각 엔티티의 `create*()` 메서드 파라미터를 확인하고 수정해야 합니다

2. **데이터베이스 설정**
   - 통합 테스트는 실제 데이터베이스 또는 인메모리 DB를 사용합니다
   - 테스트 격리를 위해 `@Transactional` 또는 `@DirtiesContext` 사용 고려

3. **비관적 락 설정 확인**
   - `ProductRepository.findByIdWithLock()`이 `@Lock(LockModeType.PESSIMISTIC_WRITE)` 어노테이션을 사용하는지 확인
   - 필요시 다른 리포지토리에도 비관적 락 적용

## 기대 효과

1. **데이터 정합성 보장**: 동시 요청 상황에서도 재고, 쿠폰, 결제 상태가 정확하게 관리됨
2. **성능 검증**: 락 사용으로 인한 성능 저하를 측정하고 최적화 포인트 발견
3. **버그 사전 방지**: 프로덕션 배포 전 동시성 이슈를 발견하고 해결

## 향후 개선 사항

1. **포인트 동시성 테스트 추가**
   - 여러 사용자가 동시에 포인트 사용
   - 동일 사용자의 동시 포인트 적립/사용

2. **주문 취소 동시성 테스트**
   - 결제와 취소가 동시에 발생하는 경우
   - 재고 복구가 정확하게 처리되는지

3. **성능 테스트**
   - 더 많은 동시 요청 (100, 1000개)으로 스트레스 테스트
   - 응답 시간 측정 및 임계값 설정