# 캐시 전략 설계 보고서

## 목차
1. [개요](#1-개요)
2. [캐시 도입 배경](#2-캐시-도입-배경)
3. [Local Cache 전략](#3-local-cache-전략)
4. [Redis Cache 전략](#4-redis-cache-전략)
5. [비교 및 선택 기준](#5-비교-및-선택-기준)
6. [결론](#6-결론)

---

## 1. 개요

본 문서는 이커머스 서비스에서 DB 부하를 줄이고 응답 속도를 개선하기 위해 적용한 캐시 전략에 대해 설명합니다.

**적용된 캐시 종류**
- **Local Cache**: 카테고리 목록 조회
- **Redis Cache**: 상품 목록 첫 페이지 조회

---

## 2. 캐시 도입 배경

### 2.1 문제점

자주 조회하는 데이터는 DB에서 반복적으로 읽어오게 되는데, 사용자가 많아질 경우 다음과 같은 문제가 발생합니다:

- **빈번한 DB 조회**: 동일한 데이터에 대한 반복적인 조회 요청
- **DB 부하 증가**: 조회 트래픽 증가로 인한 DB 성능 저하
- **느린 응답 속도**: DB I/O로 인한 지연 시간 증가

### 2.2 해결 방안

자주 조회되는 데이터는 DB에서 읽어와 **캐시(Cache)**에 저장하고, 클라이언트 요청 시 DB를 거치지 않고 캐시의 데이터를 직접 반환합니다.

**기대 효과**
- DB 부하 감소
- 응답 속도 개선
- 전체 시스템 성능 향상

---

## 3. Local Cache 전략

### 3.1 Local Cache 특징

- **저장 위치**: 각 인스턴스의 JVM Heap 메모리에 저장
- **생명 주기**: 인스턴스마다 독립적으로 생성 및 관리
- **접근 속도**: 네트워크 왕복 없이 메모리에서 직접 조회 (Redis 대비 1~2ms 빠름)

### 3.2 제약 사항

**정합성 문제**
- 다중 분산 서버 환경에서 한 서버의 캐시가 업데이트되어도 다른 서버의 캐시는 업데이트되지 않습니다.
- 서버 간 데이터 불일치가 발생할 수 있습니다.

**적용 조건**
- 자주 변하지 않는 고정적인 데이터에만 사용해야 합니다.

### 3.3 적용 사례: 카테고리 목록 조회

**선택 이유**

1. **데이터 특성**
   - 카테고리 목록은 자주 변하지 않는 고정적인 데이터입니다.
   - 변경 빈도가 매우 낮아 정합성 문제가 발생할 가능성이 낮습니다.

2. **성능 우선**
   - Redis Cache 대비 네트워크 왕복이 없어 **1~2ms 더 빠릅니다**.
   - 극도로 빠른 응답 속도가 필요한 API에 적합합니다.

3. **Redis 부하 분산**
   - Redis에 저장할 경우 Redis에도 부하가 쌓이므로, Local Cache로 분리하여 Redis 부하를 줄였습니다.

---

## 4. Redis Cache 전략

### 4.1 Redis Cache 특징

- **저장 위치**: 외부 Redis 서버 (공용 데이터 저장소)
- **정합성**: 모든 서버가 동일한 Redis에 접근하므로 서버 간 정합성 보장
- **성능**: 메모리 기반으로 DB 조회보다 훨씬 빠른 속도 제공

### 4.2 적용 조건

Redis Cache는 다음과 같은 데이터에 적합합니다:
- 고정적이지 않고 자주 변하는 데이터
- 사용자들이 빈번하게 조회하는 데이터
- 다중 서버 환경에서 정합성이 중요한 데이터

### 4.3 적용 사례: 상품 목록 첫 페이지 조회

**대상 데이터**
- 카테고리별 상품 첫 페이지
- 분류 타입별 상품 목록 조회 데이터

**선택 이유**

1. **높은 조회 빈도**
   - 상품 첫 페이지는 대부분의 사용자가 조회하는 핫 데이터(Hot Data)입니다.
   - 트래픽이 집중되는 엔드포인트로 캐싱 효과가 극대화됩니다.

2. **빈번한 쓰기 작업**
   - 상품의 CUD(Create, Update, Delete) 작업이 빈번하게 발생합니다.
   - 데이터 변경 시 캐시 무효화 및 재생성이 필요합니다.

3. **다중 서버 정합성 필요**
   - Local Cache를 사용할 경우 서버 간 동기화 문제가 발생합니다.
   - Redis는 공용 데이터 저장소이므로 모든 서버가 동일한 데이터에 접근하여 정합성 문제를 해결합니다.

---

## 5. 비교 및 선택 기준

### 5.1 비교표

| 항목 | Local Cache | Redis Cache |
|:---|:---|:---|
| **저장 위치** | JVM Heap 메모리 | 외부 Redis 서버 |
| **조회 속도** | 매우 빠름 (1~2ms 우위) | 빠름 (네트워크 왕복 필요) |
| **정합성** | 서버 간 불일치 가능 | 모든 서버 간 일관성 보장 |
| **적용 대상** | 고정적이고 변경 빈도가 낮은 데이터 | 자주 변하고 조회 빈도가 높은 데이터 |
| **확장성** | 낮음 (분산 환경에서 제약) | 높음 (분산 환경 최적화) |
| **부하 분산** | 각 서버에 분산 | Redis 서버에 집중 |

### 5.2 선택 기준

**Local Cache 선택 기준**
- 데이터 변경 빈도가 매우 낮음
- 극도로 빠른 응답 속도가 필요함
- 서버 간 정합성이 중요하지 않음

**Redis Cache 선택 기준**
- 데이터 변경 빈도가 높음
- 조회 빈도가 매우 높음
- 다중 서버 환경에서 정합성이 중요함

---

## 6. 결론

본 프로젝트에서는 데이터 특성에 따라 최적의 캐시 전략을 선택하여 적용했습니다:

| 기능 | 캐시 종류 | 선택 이유 |
|:---|:---|:---|
| **카테고리 목록 조회** | Local Cache | 고정 데이터, 최고 속도, Redis 부하 분산 |
| **상품 목록 첫 페이지** | Redis Cache | 높은 조회/변경 빈도, 다중 서버 정합성 |

이러한 전략을 통해 **DB 부하 감소**, **응답 속도 개선**, **시스템 확장성 향상**을 동시에 달성했습니다.