# 📌 동시성 이슈 분석 보고서 (Concurrency Report)

## 1. 개요
이 문서는 이커머스 서비스 개발 과정에서 발견된 **동시성 문제(Concurrency Issue)** 들과, 이를 해결하기 위해 적용한 **낙관적 락 / 비관적 락 전략**, 그리고 **트랜잭션 구조 개선 방안**을 정리한 보고서입니다.

---

## 2. 현재 서비스의 주요 동시성 이슈

### 🔥 2.1 상품 재고(Inventory)
- 상품 재고 수정
- 주문 시 재고 감소
- 주문 실패 시 재고 원복(롤백)

### 🎫 2.2 쿠폰(Coupon)
- 쿠폰 발급 시 쿠폰 마스터 수량 감소
- 사용자 쿠폰 사용 시 사용자 쿠폰 수량 감소
- 주문 실패 시 사용자 쿠폰 수량 원복

### 💰 2.3 사용자 포인트(Point)
- 포인트 충전
- 주문 시 포인트 차감
- 주문 실패 시 포인트 원복

---

## 3. 낙관적 락(Optimistic Lock) vs 비관적 락(Pessimistic Lock)

### ✔️ 낙관적 락 (Optimistic Lock)

**정의:** 충돌이 거의 없다고 가정하고, 트랜잭션 종료 시점에 버전 충돌 검사. 충돌 발생 시 예외 → 재시도 로직 수행.

#### ✅ 장점
1. DB 레벨 락이 걸리지 않아 대기 없음
2. 데드락(Deadlock) 없음
3. 읽기 위주 트래픽이 많은 환경에 최적

#### ❌ 단점
1. 충돌이 잦으면 재시도 과다 → 성능 저하
2. 트랜잭션이 길어지면 충돌 확률 급증
3. 쓰기 경쟁이 많으면 적합하지 않음

---

### ✔️ 비관적 락 (Pessimistic Lock)

**정의:** 데이터 접근 시점에 즉시 락을 걸고, 트랜잭션 종료까지 다른 접근을 차단.

#### ✅ 장점
1. 동시 수정 충돌 거의 없음 → 가장 안전
2. 즉시 일관성과 원자성 보장
3. 재시도 로직 불필요

#### ❌ 단점
1. 락 경쟁 → 대기 시간 증가
2. TPS 감소
3. 데드락 위험 존재
4. 트랜잭션이 길어지면 전체 서비스가 영향을 받음

---

## 4. 각 기능별 적용한 락 전략

### 🔒 4.1 비관적 락(Pessimistic Lock)

| 기능 | 이유 |
|------|------|
| 상품 재고 수정 | 실시간 동시 접근 가능성이 높고 정확한 재고 관리가 필수 |
| 주문 시 상품 재고 감소 | 다수 사용자가 동시에 같은 상품을 구매할 수 있음 |
| 주문 실패 시 재고 원복 | 재고는 항상 비관적 락으로 일관성 유지 |
| 쿠폰 발급 시 쿠폰 마스터 수량 감소 | 선착순 발급 → 강한 동시성 경쟁 발생 |

➡️ **공통점:** 다수 사용자가 동시에 접근하는 리소스 → 비관적 락이 안정적

---

### ✔️ 4.2 낙관적 락(Optimistic Lock)

| 기능 | 이유 |
|------|------|
| 사용자 쿠폰 수량 감소 | 사용자 1명이 관리하는 데이터 → 충돌 가능성 매우 낮음 |
| 주문 실패 시 사용자 쿠폰 원복 | 동일한 이유로 낙관적 락 충분 |
| 포인트 충전 | 특정 사용자만 접근하는 데이터 |
| 포인트 사용 / 원복 | 사용자 단위 리소스 → 충돌 적음 |

➡️ **공통점:** "사용자 단독 리소스" → 낙관적 락이 성능, 효율 모두 적합

---

## 5. 트랜잭션 구조 개선안

### ⚠️ 문제점 1
`CreateOrderFromCartUseCase` / `CreateOrderFromProductUseCase` 에서 **트랜잭션이 지나치게 큼** → 주문 생성 과정에서 모든 로직이 하나의 트랜잭션에 묶여 있어 병목 발생

### ✔ 해결책 1: 트랜잭션 최소화
- **검증 + 계산 로직**은 트랜잭션 없이 먼저 처리
- 실제 DB 수정만 트랜잭션으로 묶기
  - 상품 재고 감소
  - 쿠폰 수량 감소
  - 포인트 차감
  - 주문/결제 생성

➡️ 트랜잭션 크기 줄여 DB 락 점유 시간 축소

---

### ⚠️ 남아있는 문제점
비관적 락을 사용하는 **상품 재고 감소 로직**이 트랜잭션 안에 있어 트랜잭션이 끝날 때까지 상품 구매가 차단됨

### ✔ 해결책 2: 재고 로직 트랜잭션 분리
- **재고 감소만** 별도의 트랜잭션(`REQUIRES_NEW`) 으로 먼저 수행
- 이후 트랜잭션 실패 시 직접 재고 복구하는 **보상 로직** 작성

➡️ 재고 락 점유 시간을 최소화

---

### ⚠️ 남아있는 문제점
이후 트랜잭션이 여전히 많은 로직을 가짐 → 또다시 병목 가능

### ✔ 해결책 3: 포인트/쿠폰 로직까지 트랜잭션에서 분리
- **포인트 차감**
- **쿠폰 사용**

이 부분도 별도의 트랜잭션으로 분리해 병렬성 극대화

---

## 6. 결제 실패 시 보상 트랜잭션(Compensation)

### ⚠️ 문제점
`compensationService` 에서 재고/쿠폰/포인트 원복이 모두 `REQUIRES_NEW` 로 엮여 있음 → 중간에 실패하면 그 이전 보상은 성공, 이후 보상은 실패하는 **불완전한 상태** 발생

### ✔ 해결책 1 (현 구조에서 가능)
- 실패한 보상 트랜잭션을 **기록**
- 관리자 또는 배치에서 재처리하도록 설계 → **"실패 보상 내역 로그 시스템"** 도입

### ✔ 해결책 2 (권장: 이벤트 기반 SAGA 패턴)
- 보상 트랜잭션을 **이벤트 기반**으로 분리
- 실패 시 retry, DLQ, 보상 이벤트 등으로 완전한 복구 흐름 제공
- 실제 대형 서비스에서 주로 사용하는 방식

---

## 7. 결론

### ✅ 핵심 요약
- **재고/쿠폰 마스터** 등 공유 자원 → **비관적 락**
- **사용자 단독 자원**(포인트/사용자 쿠폰) → **낙관적 락**
- 트랜잭션은 **작게**, 보상 트랜잭션은 **독립적으로**
- 궁극적으로는 **SAGA 기반의 이벤트 보상 모델**로 확장 가능