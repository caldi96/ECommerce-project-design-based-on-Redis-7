# 분산락 전략 설계 보고서

## 목차
1. [개요](#1-개요)
2. [쿠폰 발급 시스템](#2-쿠폰-발급-시스템)
3. [상품 재고 관리 시스템](#3-상품-재고-관리-시스템)
4. [최종 아키텍처](#4-최종-아키텍처)
5. [결론](#5-결론)

---

## 1. 개요

본 문서는 이커머스 서비스에서 발생하는 동시성 문제를 해결하기 위해 적용한 분산락 전략에 대해 설명합니다.
- **쿠폰 발급**: Redis 분산락 (Pub/Sub 방식)
- **상품 재고**: Redis Lua Script (원자적 처리)

---

## 2. 쿠폰 발급 시스템

### 2.1 기존 방식의 문제점

기존에는 쿠폰 수량 감소를 위해 RDBMS의 **비관적 락(Pessimistic Lock)**을 적용했으나, 트래픽 증가에 따라 확장성 및 성능상의 문제가 발생했습니다.

#### 주요 문제점

1. **DB Connection Pool 고갈**
   - 수천~수만 명이 동시에 쿠폰 발급 API를 호출하면 모두 같은 레코드에 락을 걸기 위해 DB Connection Pool에 몰립니다.
   - Connection Pool 고갈로 인한 응답 지연 및 타임아웃이 발생합니다.

2. **DB 병목 현상**
   - DB가 병목(Bottleneck)이 되어 전체 시스템 성능이 급격히 저하됩니다.
   - 하나의 트랜잭션이 쿠폰 발급 로직 전체를 담당하기 때문에, 로직이 조금만 복잡해져도 락 유지 시간이 길어집니다.

3. **확장성 한계**
   - 비관적 락은 대략 수백 TPS 수준까지만 실효성이 있습니다.
   - 수천~수만 TPS 상황에서는 DB가 순간적으로 다운되거나 장애로 이어질 수 있습니다.

### 2.2 해결 방안: Redis 분산락 (Pub/Sub 방식)

**Redisson 라이브러리**를 활용한 Pub/Sub 방식의 Redis 분산락으로 전환했습니다.

#### Redis 분산락의 장점

- **높은 처리 성능**
  - Redis는 메모리 기반이며 단일 스레드로 명령을 처리하기 때문에 락 획득/해제가 마이크로초(μs) 단위로 처리됩니다.
  - 수천~수만 TPS의 트래픽도 안정적으로 처리 가능합니다.

- **뛰어난 확장성**
  - 분산 환경(다중 서버)에서 안정적인 락을 보장합니다.
  - WAS 서버가 1대에서 100대로 확장되어도 Redis 락은 하나의 중앙 Redis 노드에서 일관성 있게 처리됩니다.

- **효율적인 대기 메커니즘**
  - Pub/Sub 이벤트 기반으로 락 대기를 처리하여 리소스 낭비가 최소화됩니다.

### 2.3 비교표

| 항목 | DB 비관적 락 | Redis 분산락 (Pub/Sub) |
|:---|:---|:---|
| **처리 성능** | 낮음 (TPS 한계 존재) | 매우 높음 (수만 TPS 가능) |
| **락 대상** | DB 레코드 | Redis 키 |
| **확장성** | 낮음 | 높음 (다중 서버 환경 최적화) |
| **락 대기 방식** | DB 세션 대기, 타임아웃 위험 존재 | Pub/Sub 이벤트 기반 효율적 대기 |
| **장애 전파** | DB 장애 → 전체 서비스 영향 | Redis 장애만 분리적으로 영향 |
| **Deadlock 위험** | 있음 | 거의 없음 (TTL 기반) |
| **비용** | 트랜잭션 비용 큼 | 메모리 기반으로 매우 작음 |

### 2.4 구현 상세

**락 키(Lock Key) 설계**
```
"coupon:issue:" + couponId
```
- 쿠폰 ID별로 고유한 Redis 키를 생성하여 쿠폰별 독립적인 락 관리가 가능합니다.

---

## 3. 상품 재고 관리 시스템

### 3.1 배경 및 문제 인식

주문 시 상품 재고 차감에 DB 락을 사용했으나, 인기 상품의 경우 쿠폰 발급과 유사한 동시성 문제가 발생할 수 있습니다.

#### 핵심 요구사항
- 상품 재고는 **0.1초 이내**에 모든 작업을 완료하고 락을 해제해야 하는 경우가 있습니다.
- Redis Pub/Sub 분산락은 `락 획득 → 비즈니스 로직 실행 → 락 해제` 과정에서 Pub/Sub 오버헤드가 발생할 가능성이 있습니다.

### 3.2 해결 방안: Lua Script 기반 원자적 처리

**Lua Script**를 활용하여 Redis 내부에서 재고 연산을 원자적으로 처리합니다.

#### Lua Script의 장점

1. **완벽한 원자성 보장**
   - Lua Script는 Redis 내부에서 한 번에 실행되며 원자성이 완벽하게 보장됩니다.
   - Redis는 싱글 스레드이므로 동시 요청이 들어와도 순차적으로 처리되어 동시성 문제가 해결됩니다.

2. **마이크로초(μs) 단위 처리 속도**
   - 연산 시간이 마이크로초 단위로 매우 빠릅니다.
   - 락 획득/해제 오버헤드 없이 즉시 재고 연산이 가능합니다.

3. **네트워크 오버헤드 최소화**
   - 여러 Redis 명령을 하나의 Lua Script로 묶어 실행하므로 네트워크 왕복이 최소화됩니다.

### 3.3 아키텍처 설계

#### 비동기 DB 동기화 전략

- DB의 재고 차감은 **비동기 이벤트**로 처리하여 유연한 구조를 구현했습니다.
- Redis에서 빠르게 재고를 차감한 후, DB는 비동기적으로 업데이트됩니다.

#### 락 키(Lock Key) 설계

```
"stock:product:" + productId
```
- 상품 ID별로 고유한 Redis 키를 생성하여 상품별 독립적인 재고 관리가 가능합니다.

#### 정합성 보장 메커니즘

**1. 주기적 동기화 스케줄러**
- **1분마다**: Redis와 DB의 재고 정합성을 검증하고 동기화
- **5분마다**: Redis에 없는 상품은 DB 재고로 초기화

**2. 이벤트 리스너**
- 재고 변경 이벤트를 비동기로 수신하여 DB에 반영

---

## 4. 최종 아키텍처

### 4.1 재고 관리 플로우

```
┌───────────────────────────────────────────────────┐
│          모든 재고 관련 작업                        │
├───────────────────────────────────────────────────┤
│ 1. 주문 생성        → Redis (Lua Script)          │
│ 2. 주문 취소        → DB + Redis (즉시 동기화)      │
│ 3. 결제 실패 보상   → Redis                        │
│ 4. 상품 CRUD       → DB + Redis (동시 업데이트)    │
└───────────────────────────────────────────────────┘
                      ↓
        ┌───────────────────────┐
        │   StockEventListener  │
        │   (비동기 DB 동기화)   │
        └───────────────────────┘
                      ↓
        ┌───────────────────────┐
        │  StockSyncScheduler   │
        │  (주기적 정합성 검증)  │
        └───────────────────────┘
```

### 4.2 핵심 설계 원칙

1. **성능 우선**
   - Redis를 활용하여 읽기/쓰기 성능을 극대화합니다.

2. **데이터 정합성**
   - 스케줄러와 이벤트 리스너를 통해 Redis-DB 간 정합성을 보장합니다.

3. **장애 격리**
   - Redis 장애 시에도 DB를 통한 복구가 가능하도록 설계했습니다.

4. **확장성**
   - 분산 환경에서도 안정적으로 동작하도록 중앙화된 락 메커니즘을 적용했습니다.

---

## 5. 결론

본 프로젝트에서는 동시성 제어를 위해 다음과 같은 차별화된 전략을 수립했습니다:

- **쿠폰 발급**: Redis Pub/Sub 분산 락 (Redisson)
- **상품 재고**: Redis Lua Script (원자적 처리)

각 도메인의 특성에 맞는 최적의 기술을 선택하여 **높은 처리량(High Throughput)**, **낮은 지연시간(Low Latency)**, **데이터 정합성(Data Consistency)**을 동시에 달성했습니다.